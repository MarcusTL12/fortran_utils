! T_TYPE contained type
! T_ALIAS optional; contained type name alias
! T_MOD defined if T_TYPE if a derived type. This is the module of the type.
! T_HASH optional; defined to derive hash
! T_SHOW optional; defined to derive show
! T_SHOW_MOD optional; defined if show is implemented elsewhere from the
!       definition of T
! T_DISABLE_EQ optional; defined if contained type does not implement eq/neq
! T_LOGIC optinal; defined to change eq

#include "macros.f90_template"

! defining the alias
#ifndef T_ALIAS
#define T_ALIAS T_TYPE
#endif

! name of vec type
#define VEC CAT2(vecdeque_,T_ALIAS)

! name of module
#define MOD_NAME CAT2(VEC,_mod)

! the thing you use to use T_TYPE
#ifdef T_MOD
#define TT_TYPE type(T_TYPE)
#else
#define TT_TYPE T_TYPE
#endif

! defines the contained vec type
#ifndef T_VEC
#define T_VEC CAT2(vec_,T_ALIAS)
#endif

! defining the vec module
#ifndef T_VEC_MOD
#define T_VEC_MOD CAT2(T_VEC,_mod)
#endif

! macro for defining unique function/subroutine names
#define F(f) CAT3(f,_,VEC)

! the default initial capacity of a new vector
#define INIT_CAP 8

! the factor to increase the vec with when reallocating
#define GROWTH_FACTOR 2

module MOD_NAME
#ifdef T_MOD
    use T_MOD
#endif
#ifdef T_HASH
    use hash_mod
#endif
#ifdef T_SHOW
    use show_mod
#endif
#ifdef T_SHOW_MOD
    use T_SHOW_MOD
#endif
    use T_VEC_MOD
    use ownership_mod
    implicit none
    !
    private
    !
    public :: VEC
    type VEC
        integer     :: head, tail
        type(T_VEC) :: data
    contains
        private
        final :: F(finalizer)
        procedure, public   :: with_capacity => F(with_capacity)
        procedure, public   :: new => F(new)
        procedure, public   :: push => F(push)
        procedure, public   :: at => F(at)
        procedure           :: F(from_vec)
        procedure           :: F(from_arr)
        generic, public     :: assignment(=) => F(from_vec), F(from_arr)
        procedure, public   :: pop_front => F(pop_front)
        procedure           :: reallocate => F(reallocate)
    end type
    !
    public :: size
    interface size
        module procedure F(size)
    end interface
    !
    public :: transfer
    interface transfer
        module procedure F(transfer)
    end interface
    !
    public :: drop
    interface drop
        module procedure F(finalizer)
    end interface
#ifdef T_SHOW
    public :: show
    interface show
        module procedure F(show)
    end interface
#endif
contains
    subroutine F(finalizer) (self)
        implicit none
        !
        type(VEC), intent(inout) :: self
        !
        call drop(self%data)
    end subroutine
    !
    integer function F(size) (self)
        implicit none
        !
        type(VEC), intent(in) :: self
        !
        if (self%tail >= self%head) then
            F(size) = self%tail - self%head
        else
            F(size) = size(self%data) - self%head + self%tail
        end if
    end function
    !
    subroutine F(transfer) (a, b)
        implicit none
        !
        type(VEC), intent(inout) :: a, b
        !
        b%head = a%head
        b%tail = a%tail
        call transfer(a%data, b%data)
    end subroutine
    !
    subroutine F(with_capacity) (self, cap)
        implicit none
        !
        class(VEC), intent(inout) :: self
        integer, intent(in) :: cap
        !
        call drop(self)
        call self%data%with_capacity(cap)
        call self%data%set_length(cap)
        self%head = 1
        self%tail = 1
    end subroutine
    !
    subroutine F(new) (self)
        implicit none
        !
        class(VEC), intent(inout) :: self
        !
        call self%with_capacity(INIT_CAP)
    end subroutine
    !
    subroutine F(push) (self, val)
        implicit none
        !
        class(VEC), intent(inout) :: self
        TT_TYPE, intent(inout) :: val
        !
        call transfer(val, self%data%at(self%tail))
        self%tail = self%tail + 1
        !
        if (self%tail > size(self%data)) then
            self%tail = 1
        end if
        !
        if (self%tail == self%head) then
            call self%reallocate()
        end if
    end subroutine
    !
    function F(at) (self, i)
        implicit none
        !
        class(VEC), intent(in) :: self
        integer, intent(in) :: i
        TT_TYPE, pointer :: F(at)
        !
        if (i + self%head - 1 <= size(self%data)) then
            F(at) => self%data%at(i + self%head - 1)
        else
            F(at) => self%data%at(i + self%head - 1 - size(self%data))
        end if
    end function
    !
    subroutine F(reallocate) (self)
        implicit none
        !
        class(VEC), intent(inout) :: self
        type(VEC) :: other
        integer :: i
        !
        call other%with_capacity(size(self%data) * GROWTH_FACTOR)
        !
        do i = 1, size(self%data)
            call other%push(self%at(i))
        end do
        !
        call transfer(other, self)
    end subroutine
    !
    subroutine F(from_vec) (self, other)
        implicit none
        !
        class(VEC), intent(inout) :: self
        type(VEC), intent(in) :: other
        TT_TYPE :: buf
        integer :: i
        !
        call self%with_capacity(size(other))
        do i = 1, size(other)
            associate (p=>other%at(i))
                buf = p
                call self%push(buf)
            end associate
        end do
    end subroutine
    !
    subroutine F(from_arr) (self, other)
        implicit none
        !
        class(VEC), intent(inout) :: self
        TT_TYPE, intent(in) :: other(:)
        TT_TYPE :: buf
        integer :: i
        !
        call self%with_capacity(size(other))
        do i = 1, size(other)
            associate (p=>other(i))
                buf = p
                call self%push(buf)
            end associate
        end do
    end subroutine
    !
    logical function F(pop_front) (self, x) result(nonempty)
        implicit none
        !
        class(VEC), intent(inout) :: self
        TT_TYPE, intent(inout) :: x
        !
        nonempty = size(self) > 0
        !
        if (nonempty) then
            call transfer(self%data%at(self%head), x)
            self%head = self%head + 1
            if (self%head > size(self%data)) self%head = 1
        end if
    end function
#ifdef T_SHOW
    subroutine F(show) (v)
        implicit none
        !
        type(VEC), intent(in) :: v
        integer :: i
        !
        call show('[')
        do i = 1, size(v)
            call show(v%at(i))
            if (i < size(v)) call show(", ")
        end do
        call show(']')
    end subroutine
#endif
end module

#undef T_TYPE
#undef T_ALIAS
#undef T_MOD
#undef T_VEC
#undef T_VEC_MOD
#undef TT_TYPE
#undef T_VEC
#undef VEC
#undef T_HASH
#undef T_SHOW
#undef T_DISABLE_EQ
