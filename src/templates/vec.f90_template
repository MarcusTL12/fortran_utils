! T_TYPE contained type
! T_ALIAS optional; contained type name alias
! T_MOD defined if T_TYPE if a derived type. This is the module of the type.
! T_VEC defined if you want to override the auto generated name i.e. string
! T_HASH defined to derive hash
! T_SHOW defined to derive show
! T_SHOW_MOD defined if show is implemented elsewhere from the definition of T
! T_DISABLE_EQ defined if contained type does not implement eq/neq
! T_LOGIC defined to change eq

#include "macros.f90_template"

! defining the alias
#ifndef T_ALIAS
#define T_ALIAS T_TYPE
#endif

! name of vec type
#ifdef T_VEC
#define VEC T_VEC
#else
#define VEC CAT2(vec_,T_ALIAS)
#endif

! name of module
#define MOD_NAME CAT2(VEC,_mod)

! the thing you use to use T_TYPE
#ifdef T_MOD
#define TT_TYPE type(T_TYPE)
#else
#define TT_TYPE T_TYPE
#endif

! macro for defining unique function/subroutine names
#define F(f) CAT3(f,_,VEC)

! the default initial capacity of a new vector
#define INIT_CAP 8

! the factor to increase the vec with when reallocating
#define GROWTH_FACTOR 2

module MOD_NAME
#ifdef T_MOD
    use T_MOD
#endif
#ifdef T_HASH
    use hash_mod
#endif
#ifdef T_SHOW
    use show_mod
#endif
#ifdef T_SHOW_MOD
    use T_SHOW_MOD
#endif
    use ownership_mod
    implicit none
    !
    private
    !
    public :: VEC
    type VEC
        integer :: length
        logical :: owned = .false.
        TT_TYPE, pointer :: data(:) => null()
    contains
        private
        final :: F(finalizer)
        procedure, public   :: with_capacity => F(with_capacity)
        procedure, public   :: new => F(new)
        procedure, public   :: push => F(push)
        procedure, public   :: at => F(at)
        procedure           :: F(from_vec)
        procedure           :: F(from_arr)
        generic, public     :: assignment(=) => F(from_vec), F(from_arr)
        procedure, public   :: clear => F(clear)
        procedure, public   :: from_borrow => F(from_borrow)
        procedure           :: F(from_buffer)
        procedure           :: F(from_empty_buffer)
        generic, public     :: from_buffer => F(from_buffer), &
            F(from_empty_buffer)
        procedure, public   :: as_slice => F(as_slice)
#ifndef T_DISABLE_EQ
        procedure           :: F(eq)
        generic, public     :: operator(==) => F(eq)
        procedure           :: F(neq)
        generic, public     :: operator(/=) => F(neq)
#endif
        procedure, public   :: truncate => F(truncate)
        procedure, public   :: extend => F(extend)
        procedure, public   :: set_length => F(set_length)
        procedure, public   :: pop => F(pop)
    end type
    !
    public :: size
    interface size
        module procedure F(size)
    end interface
    !
    public :: transfer
    interface transfer
        module procedure F(transfer)
    end interface
    !
    public :: drop
    interface drop
        module procedure F(finalizer)
    end interface
    !
#ifdef T_HASH
    public :: hash
    interface hash
        module procedure F(hash)
    end interface
#endif
#ifdef T_SHOW
    public :: show
    interface show
        module procedure F(show)
    end interface
#endif
contains
    subroutine F(finalizer) (self)
        implicit none
        !
        type(VEC), intent(inout) :: self
        integer :: i
        !
        if (self%owned .and. associated(self%data)) then
            ! print *, "Deallocated"
            do i = 1, size(self)
                call drop(self%data(i))
            end do
            deallocate (self%data)
            self%owned = .false.
        end if
    end subroutine
    !
    subroutine F(with_capacity) (self, cap)
        implicit none
        !
        class(VEC), intent(inout) :: self
        integer, intent(in) :: cap
        !
        call drop(self)
        !
        self%owned = .true.
        allocate (self%data(cap))
        self%length = 0
    end subroutine
    !
    subroutine F(new) (self)
        implicit none
        !
        class(VEC), intent(inout) :: self
        !
        call self%with_capacity(INIT_CAP)
    end subroutine
    !
    pure integer function F(size) (self)
        implicit none
        !
        type(VEC), intent(in) :: self
        !
        F(size) = self%length
    end function
    !
    subroutine F(reallocate) (self)
        implicit none
        !
        type(VEC), intent(inout) :: self
        TT_TYPE, pointer :: ndata(:)
        integer :: i
        !
        ! print *, "reallocating"
        !
        allocate (ndata(size(self%data) * GROWTH_FACTOR))
        !
        do i = 1, size(self)
            call transfer(self%data(i), ndata(i))
        end do
        !
        if (self%owned) deallocate (self%data)
        self%data => ndata
    end subroutine
    !
    subroutine F(push) (self, val)
        implicit none
        !
        class(VEC), intent(inout) :: self
        TT_TYPE, intent(inout)    :: val
        !
        ! print *, size(self), size(self%data)
        !
        if (size(self) >= size(self%data)) then
            call F(reallocate) (self)
        end if
        !
        self%length = self%length + 1
        call transfer(val, self%data(self%length))
    end subroutine
    !
    function F(at) (self, ind)
        implicit none
        !
        class(VEC), intent(in)   :: self
        integer, intent(in)         :: ind
        TT_TYPE, pointer            :: F(at)
        !
        F(at) => self%data(ind)
    end function
    !
    subroutine F(transfer) (a, b)
        implicit none
        !
        type(VEC), intent(inout) :: a, b
        !
        call drop(b)
        !
        b%data => a%data
        b%length = a%length
        if (a%owned) nullify (a%data)
        b%owned = a%owned
        a%owned = .false.
    end subroutine
    !
    subroutine F(from_vec) (self, other)
        implicit none
        !
        class(VEC), intent(inout)   :: self
        type(VEC), intent(in)       :: other
        TT_TYPE                     :: buffer
        integer                     :: i
        !
        call self%with_capacity(size(other))
        !
        do i = 1, size(other)
            buffer = other%data(i)
            call self%push(buffer)
        end do
    end subroutine
    !
    subroutine F(from_arr) (self, other)
        implicit none
        !
        class(VEC), intent(inout)   :: self
        TT_TYPE, intent(in)         :: other(:)
        TT_TYPE                     :: buffer
        integer                     :: i
        !
        call self%with_capacity(size(other))
        !
        do i = 1, size(other)
            buffer = other(i)
            call self%push(buffer)
        end do
    end subroutine
    !
    subroutine F(clear) (self)
        implicit none
        !
        class(VEC), intent(inout) :: self
        integer :: i
        !
        do i = 1, size(self)
            call drop(self%data(i))
        end do
        !
        self%length = 0
    end subroutine
    !
    subroutine F(from_borrow) (self, other)
        implicit none
        !
        class(VEC), intent(inout) :: self
        TT_TYPE, pointer, intent(in) :: other(:)
        !
        call drop(self)
        self%data => other
        self%length = size(other)
        self%owned = .false.
    end subroutine
    !
    subroutine F(from_buffer) (self, buffer, length)
        implicit none
        !
        class(VEC), intent(inout) :: self
        TT_TYPE, pointer, intent(in) :: buffer(:)
        integer, intent(in) :: length
        !
        call drop(self)
        self%data => buffer
        self%length = length
        self%owned = .false.
    end subroutine
    !
    subroutine F(from_empty_buffer) (self, buffer)
        implicit none
        !
        class(VEC), intent(inout) :: self
        TT_TYPE, pointer, intent(in) :: buffer(:)
        !
        call drop(self)
        self%data => buffer
        self%length = 0
        self%owned = .false.
    end subroutine
    !
    function F(as_slice) (self)
        implicit none
        !
        class(VEC), intent(in) :: self
        TT_TYPE, pointer :: F(as_slice) (:)
        !
        F(as_slice) => self%data(1:size(self))
    end function
    !
#ifdef T_HASH
    function F(hash) (self) result(h)
        implicit none
        !
        class(VEC), intent(in) :: self
        integer(8) :: h
        integer    :: i
        !
        h = transfer((/-1748475402, 1824152677/), h)
        !
        do i = 1, size(self)
            call fuse_hash(hash(self%data(i)), h)
        end do
    end function
#endif
    !
#ifndef T_DISABLE_EQ
    logical function F(eq) (self, other)
        implicit none
        !
        class(VEC), intent(in) :: self
        type(VEC), intent(in) :: other
        integer :: i
        !
        if (size(self) /= size(other)) then
            F(eq) = .false.
            return
        end if
        !
        F(eq) = .true.
        do i = 1, size(self)
#ifndef T_LOGIC
            if (self%data(i) /= other%data(i)) then
#else
            if (self%data(i) .neqv. other%data(i)) then
#endif
                F(eq) = .false.
                exit
            end if
        end do
    end function
    !
    logical function F(neq) (self, other)
        implicit none
        !
        class(VEC), intent(in) :: self
        type(VEC), intent(in) :: other
        !
        F(neq) = .not. (self == other)
    end function
#endif
    !
    subroutine F(truncate) (self, nlen)
        implicit none
        !
        class(VEC), intent(inout) :: self
        integer, intent(in) :: nlen
        integer :: i
        !
        do i = nlen + 1, size(self)
            call drop(self%data(i))
        end do
        !
        self%length = nlen
    end subroutine
#ifdef T_SHOW
    subroutine F(show) (v)
        implicit none
        !
        type(VEC), intent(in) :: v
        integer :: i
        !
        call show('[')
        do i = 1, size(v)
            call show(v%data(i))
            if (i < size(v)) call show(", ")
        end do
        call show(']')
    end subroutine
#endif
    subroutine F(extend) (v, d)
        implicit none
        !
        class(VEC), intent(inout) :: v
        TT_TYPE, intent(inout) :: d(:)
        integer :: i
        !
        do i = 1, size(d)
            call v%push(d(i))
        end do
    end subroutine
    !
    subroutine F(set_length) (self, l)
        implicit none
        !
        class(VEC), intent(inout) :: self
        integer, intent(in) :: l
        !
        if (l < size(self)) then
            call self%truncate(l)
        else if (l <= size(self%data)) then
            self%length = l
        else
            call F(reallocate)(self)
            self%length = l
        end if
    end subroutine
    !
    logical function F(pop) (self, x)
        implicit none
        !
        class(VEC), intent(inout) :: self
        TT_TYPE, intent(inout) :: x
        !
        F(pop) = size(self) > 0
        if (F(pop)) then
            call transfer(self%at(size(self)), x)
            self%length = size(self) - 1
        end if
    end function
end module

#undef T_TYPE
#undef T_ALIAS
#undef T_MOD
#undef TT_TYPE
#undef T_VEC
#undef VEC
#undef T_HASH
#undef T_SHOW
#undef T_DISABLE_EQ
